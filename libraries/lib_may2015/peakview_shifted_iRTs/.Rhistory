ylim = ylim, cex.names = cfg$AxisAnnotationSize,
border = NA, beside = T, plot=T, axes=F, las=2, space=c(0.3, 3)
)
# suppress 0.05 y-axis ticks
yTicks = unique(floor((axTicks(2)+.05)*10)/10)
if(showGrid)
{
abline(h=yTicks, col="lightgray", lty="dashed")
}
if(showLegend)
{
legend("topright", legend = labs, lwd = 6, col=cols, bty = "n", ncol=2 ) #, cex = cfg$AxisAnnotationSize)
}
apply(barx, 2, function(v) lines(range(v), c(0,0), lwd=cfg$AxisLineThickness, xpd=T) )
axis(2, pos=1, at = yTicks, labels = format(yTicks, 1, trim=T ),
lwd=0, lwd.ticks=cfg$AxisLineThickness, cex.axis=cfg$AxisAnnotationSize, mgp=c( 6, 1, 0 )
)
lines(x=c(1,1), y=ylim, lwd=cfg$AxisLineThickness)
title(xlab=as.expression( bquote( ""~Log[2]*"(B)" ) ), cex.lab=cfg$AxisLabelSize, mgp=c( 5.3, 1, 0 ) )
title(ylab=valLab, cex.lab=cfg$AxisLabelSize, mgp=c( 2.8, 1, 0 ) )
if(!is.null(file)) dev.off()
par(cfg$parBackup)
return(barx)
}
####################################################################################################
plotBarLegend = function(labs, cols, nCol=2, file=NULL)
{
if(!is.null(file)) pdf(file=file, onefile=T, width=cfg$PlotWidth, height=cfg$PlotHeight, family="Helvetica", pointsize=9)
par(  mar = c( 0, 0.5, 0, 0 ))
plot(0,0,type = "n", axes=F, xlab="", ylab="" )
legend("top", legend = labs, lwd = 8, col=cols, bty = "n", ncol=nCol, cex = cfg$AxisAnnotationSize, xpd=T)
if(!is.null(file)) dev.off()
par(cfg$parBackup)
}
####################################################################################################
c4s = function(m, spc) m[,colnames(m)==spc]
# accuracy: the median deviation of log-ratios to the expected value
getAcc = function(rs, spc) c4s(rs$result[[1]]$rangedAccuracy, spc)
# precision: the standard deviation of log-ratios
getPrc = function(rs, spc) c4s(rs$result[[1]]$rangedPrecision, spc)
####################################################################################################
plotRound = function(roundNames, species="ECOLI", filePrefix="", cols=NULL)
{
labs = gsub("_r1", "", roundNames)
labs = gsub("_r2", " (improved)", labs)
labs = gsub("_builtin", " (built-in)", labs)
if( is.null(cols) ) cols = brewer.pal(length(roundNames), "Dark2")
acc = t(abs(sapply(ResultSets[roundNames], getAcc, species)))
prc = t(abs(sapply(ResultSets[roundNames], getPrc, species)))
showBarPlot(
acc, cols, labs,
file=outDir+"/" + filePrefix+"_accuracy_("+species+"_logratio_delta).pdf",
valLab=bquote( group("|",Delta*"("~log[2]*"(A:B)"~")", "|") )
)
showBarPlot(
prc, cols, labs,
file=outDir+"/" + filePrefix+"_precision_("+species+"_logratio_sd).pdf",
valLab=bquote( "SD("~log[2]*"(A:B) )" )
)
return(list( labs=labs, cols=cols ))
}
####################################################################################################
software.names = c(
"DIAumpire",
"openSWATH",
"PeakView",
"Skyline",
"Spectronaut"
)
protein.experiments.r1 = c(
"DIAumpire_r1",
"openSWATH_r1",
"PeakView_r1",
"Skyline_r1",
"Spectronaut_r1"
)
protein.experiments.r2 = c(
"openSWATH_r2",
"PeakView_r2",
"Spectronaut_r2"
)
peptide.experiments.r1 = c(
"DIAumpire_peptides_r1",
"openSWATH_peptides_r1",
"PeakView_peptides_r1",
"Skyline_peptides_r1",
"Spectronaut_peptides_r1"
)
peptide.experiments.r2 = c(
"openSWATH_peptides_r2",
"PeakView_peptides_r2",
"Spectronaut_peptides_r2"
)
experimentColors = brewer.pal(10, "Paired")
names(experimentColors) = c(
"DIAumpire_r1",
"openSWATH_r1", "openSWATH_r2",
"PeakView_r1",  "PeakView_r2",
"Skyline_r1",
"Spectronaut_r1", "Spectronaut_r2"
)
if(DEBUG) cat( "R working directory: " + getwd() + "\n")
#outDir="../output"
#load(file = "../../data.fig23/log/ResultSets.rda")
outDir="../output_commonpep.5600_64w"
load(file = "../../data.commonpep.5600_64w/log/ResultSets.rda")
mkdir(outDir)
experimentNames = names(ResultSets)
experimentNames
# r1.names = experimentNames[grep("r1", experimentNames)]
# r2.names = experimentNames[grep("(openSWATH|PeakView|Spectronaut)", experimentNames)]
# r1.cols = experimentColors[r1.names]
# r2.cols = experimentColors[r2.names]
# plotRound(r1.names, species = "ECOLI", filePrefix = "round1", cols=r1.cols)
# plotRound(r1.names, species = "YEAST", filePrefix = "round1", cols=r1.cols)
# r1.labsAndCols = plotRound(r1.names, species = "HUMAN", filePrefix = "round1", cols=r1.cols)
# plotBarLegend(r1.labsAndCols$labs, r1.labsAndCols$cols, nCol=2, outDir+"/round1_legend_h.pdf")
# plotBarLegend(r1.labsAndCols$labs, r1.labsAndCols$cols, nCol=1, outDir+"/round1_legend_v.pdf")
# plotRound(r2.names, species = "ECOLI", filePrefix = "round2", cols=r2.cols)
# plotRound(r2.names, species = "YEAST", filePrefix = "round2", cols=r2.cols)
# r2.labsAndCols = plotRound(r2.names, species = "HUMAN", filePrefix = "round2", cols=r2.cols)
# plotBarLegend(r2.labsAndCols$labs, r2.labsAndCols$cols, nCol=2, outDir+"/round2_legend_h.pdf")
# plotBarLegend(r2.labsAndCols$labs, r2.labsAndCols$cols, nCol=1, outDir+"/round2_legend_v.pdf")
mvAnteil = function(spc="HUMAN", mv)
{
spcs = names(mv)
v = mv[ , spcs==spc ]
nAll = sum(v)
nMV = sum(v[-1])
return( nMV/nAll*100 )
}
mv4rs = function(rs) sapply(cfg$AllSpeciesNames, mvAnteil, rs$data$missingvalues )
nams2labs = function(nams)
{
labs = gsub("_r1", "", nams)
labs = gsub("_r2", " (improved)", labs)
labs = gsub("_peptides", "", labs)
labs = gsub("_builtin", "\n(built-in)", labs)
labs = gsub("DIAumpire", "DIA-Umpire", labs)
labs = gsub("openSWATH", "OpenSWATH", labs)
return(labs)
}
plotMissingValues = function( missingValues, file=NULL, labSize=cfg$AxisAnnotationSize, catNameShift=0 )
{
if(!is.null(file))
{
pdf(file=file, onefile=T, width=cfg$PlotWidth, height=cfg$PlotHeight, family="Helvetica", pointsize=9)
}
par(cfg$par)
par(  mar = c( 8.3, 5, .8, 0 ),
# plot axis: c(title, label, line)
# mgp = c( 4, 0.3, 0 )
mgp=c( 3.4, 1, 0 )
)
labs = nams2labs(colnames(missingValues))
barx = barplot(missingValues, names.arg = rep("", ncol(missingValues)),
beside=T, ylim=c(0,100), col=cfg$SpeciesColors, cex.axis=cfg$AxisAnnotationSize, axes=F
)
labsx = colMeans(barx)
text(labsx+.5, rep(-5, length(labs)) - catNameShift, labels = labs, xpd=T, cex=labSize, srt=90, pos=2 )
addYLab("Incomplete cases (%)", cex.lab=labSize)
addAxes(showYAxis = T, showXAxis = F, cex.axis = labSize, lwd = cfg$AxisLineThickness, showXlab = F )
if(!is.null(file)) dev.off()
par(cfg$parBackup)
}
# figure 2: missing values in round 1 peptides
mvs = sapply(ResultSets[peptide.experiments.r1], mv4rs)
plotMissingValues( mvs, file = outDir + "/" + "missing_values_peptides_r1.pdf", labSize=cfg$AxisAnnotationSize*.75, catNameShift=0)
mvs = sapply(ResultSets[protein.experiments.r1], mv4rs)
plotMissingValues( mvs, file = outDir + "/" + "missing_values_proteins_r1.pdf", labSize=cfg$AxisAnnotationSize*.75, catNameShift=0)
# make scatterplot files for all datasets
sapply( experimentNames,  plotRsToFile,  scatter=F, box=T, kde=F, showRegLines=T )
speciesLegendH(outDir + "/" + "species_legend_h.pdf")
# figure 5
# ECOLI log-ratios as boxplots combined for each software R1, R2
# having empty space for missing datasets
getLogRatios = function( rsIndex=1, species="ECOLI" )
{
if(length(rsIndex)<1)
return(NULL)
else
return(ResultSets[[rsIndex]]$result[[1]]$data[[species]]$y)
}
getProteinLogRatios = function( software="DIAumpire", species="ECOLI" )
{
# built-in
#biLR = getLogRatios( grep(software+"_builtin_r1", experimentNames), species)
# r1
r1LR = getLogRatios( grep(software+"_r1", experimentNames), species)
# r2
r2LR = getLogRatios( grep(software+"_r2", experimentNames), species)
return( list("Round 1"=r1LR, "Round 2"=r2LR) )
}
getPartialLogRatios = function( rsIndex=1, species="ECOLI", fromPart=0.0, toPart=1.0 )
{
if(length(rsIndex)<1)
{
return(NULL)
}
else
{
# increasing order of log intensities
xorder = order(ResultSets[[rsIndex]]$result[[1]]$data[[species]]$x)
# sort log ratios in the order of increasing log intensities
lrs = getLogRatios(rsIndex = rsIndex, species = species)
lrs = lrs[xorder]
n = length(lrs)
fromIdx = floor(fromPart * n)
toIdx = floor(toPart * n)
return(lrs[fromIdx:toIdx])
}
}
getPartialProteinLogRatios = function( software="DIAumpire", species="ECOLI", fromPart=0, toPart=1 )
{
cat("selecting log ratios for software: "+ software + " ...\n")
# r1
r1LR = getPartialLogRatios( grep(software+"_r1", experimentNames), species=species, fromPart, toPart)
# r2
r2LR = getPartialLogRatios( grep(software+"_r2", experimentNames), species=species, fromPart, toPart)
return( list("Round 1"=r1LR, "Round 2"=r2LR) )
}
expectedLogRatios = log2( cfg$AllExpectedAmounts[,1] / cfg$AllExpectedAmounts[,2] )
# boxplot taking all log ratios into account
showBoxPlot4Softwares = function( species="ECOLI", file=NULL  )
{
if(!is.null(file))
{
pdf(file=file, onefile=T, width=cfg$PlotWidth*2, height=cfg$PlotHeight*1.5, family="Helvetica", pointsize=9)
}
par(cfg$par)
par(  mar = c( 10.5, 5.5, .5, 0.5 ),
# plot axis: c(title, label, line)
mgp=c( 3.6, 1.0, 0 )
)
lrs = unlist( lapply(software.names, getProteinLogRatios ), recursive = F )
boxPos = c(1:2, 4:5, 7:8, 10:11, 13:14)
sepPos = c(3,6,9,12)
qboxplot( lrs, whiskerQuantile = 0.01,
ylab=as.expression( bquote( Log[2]~"(A:B)" ) ),
horizontal = F, pch=20, cex=cfg$PlotPointSize, axes=F,
cex.lab=cfg$AxisLabelSize,
at=boxPos
)
plotArea = par()$usr
# plot expectation line
abline(h=expectedLogRatios[species], lty=2, lwd=cfg$PlotCurveLineWidth )
abline(v=sepPos, lty=2, lwd=cfg$PlotCurveLineWidth, col="gray" )
addAxes(lwd = cfg$AxisLineThickness, showXlab = F, showYlab = T, showXAxis = T, showYAxis = T, cex.axis = cfg$AxisAnnotationSize )
yAxRange = par()$usr[3:4]
yAxSize = max(yAxRange) - min(yAxRange)
axis(1, labels=names(lrs), at=boxPos, lwd.ticks = cfg$AxisLineThickness, lwd=0, cex.axis=cfg$AxisAnnotationSize, las=2)
axis(1, pos=min(yAxRange)-0.36*yAxSize , labels=nams2labs(software.names), at=boxPos[(1:5)*2-1], tick=F, cex.axis=cfg$AxisAnnotationSize, las=1)
if(!is.null(file)) dev.off()
par(cfg$parBackup)
return(plotArea)
}
showBoxPlot4Softwares( species="ECOLI", file = outDir+"/software_boxplots_ecoli.pdf" )
# boxplots for low/mid/high intensity ranges
showPartialBoxPlot4Softwares = function( species="ECOLI", fromPart=0, toPart=1, file=NULL  )
{
if(!is.null(file))
{
pdf(file=file, onefile=T, width=cfg$PlotWidth*2, height=cfg$PlotHeight*1.5, family="Helvetica", pointsize=9)
}
mar = c( 0.5, 5.5, .5, 0.5 )
mgp=c( 3.6, 1.0, 0 )
par( cfg$par )
par( mar=mar, mgp=mgp )
lrs = unlist( lapply( software.names, getPartialProteinLogRatios, species, fromPart, toPart ), recursive = F )
boxPos = c( 1:3, 5:7, 9:11, 13:15, 17:19 )
boxPos = c( 1:2, 4:5, 7:8, 10:11, 13:14 )
sepPos = c( 3, 6, 9, 12 )
qboxplot( lrs, whiskerQuantile = cfg$BoxPlotWhiskerQuantile, lims=c(expectedLogRatios[species] - 3, expectedLogRatios[species] + 3.2),
ylab=as.expression( bquote( Log[2]~"(A:B)" ) ),
horizontal = F, pch=20, cex=cfg$PlotPointSize, axes=F,
cex.lab=cfg$AxisLabelSize, at=boxPos
)
plotArea = par()$usr
# plot expectation line
abline(h=expectedLogRatios[species], lty=2, lwd=cfg$PlotCurveLineWidth )
abline(v=sepPos, lty="dotted", lwd=cfg$PlotCurveLineWidth, col="gray" )
addAxes(lwd = cfg$AxisLineThickness, showXlab = F, showYlab = T, showXAxis = T, showYAxis = T, cex.axis = cfg$AxisAnnotationSize )
if(!is.null(file))
{
yAxRange = par()$usr[3:4]
yAxSize = max(yAxRange) - min(yAxRange)
axis(1, labels=names(lrs), at=boxPos, lwd.ticks = cfg$AxisLineThickness, lwd=0, cex.axis=cfg$AxisAnnotationSize, las=2)
axis(1, pos=min(yAxRange)-0.36*yAxSize , labels=nams2labs(software.names), at=boxPos[(1:5)*3-1], tick=F, cex.axis=cfg$AxisAnnotationSize, las=1)
}
# boxplots for low/mid/high intensity ranges
showPartialBoxPlot4Softwares = function( species="ECOLI", fromPart=0, toPart=1, file=NULL  )
{
if(!is.null(file))
{
pdf(file=file, onefile=T, width=cfg$PlotWidth*2, height=cfg$PlotHeight*1.5, family="Helvetica", pointsize=9)
}
mar = c( 0.5, 5.5, .5, 0.5 )
mgp=c( 3.6, 1.0, 0 )
par( cfg$par )
par( mar=mar, mgp=mgp )
lrs = unlist( lapply( software.names, getPartialProteinLogRatios, species, fromPart, toPart ), recursive = F )
boxPos = c( 1:2, 4:5, 7:8, 10:11, 13:14 )
sepPos = c( 3, 6, 9, 12 )
qboxplot( lrs, whiskerQuantile = cfg$BoxPlotWhiskerQuantile, lims=c(expectedLogRatios[species] - 3, expectedLogRatios[species] + 3.2),
ylab=as.expression( bquote( Log[2]~"(A:B)" ) ),
horizontal = F, pch=20, cex=cfg$PlotPointSize, axes=F,
cex.lab=cfg$AxisLabelSize, at=boxPos
)
plotArea = par()$usr
# plot expectation line
abline(h=expectedLogRatios[species], lty=2, lwd=cfg$PlotCurveLineWidth )
abline(v=sepPos, lty="dotted", lwd=cfg$PlotCurveLineWidth, col="gray" )
addAxes(lwd = cfg$AxisLineThickness, showXlab = F, showYlab = T, showXAxis = T, showYAxis = T, cex.axis = cfg$AxisAnnotationSize )
if(!is.null(file))
{
yAxRange = par()$usr[3:4]
yAxSize = max(yAxRange) - min(yAxRange)
axis(1, labels=names(lrs), at=boxPos, lwd.ticks = cfg$AxisLineThickness, lwd=0, cex.axis=cfg$AxisAnnotationSize, las=2)
axis(1, pos=min(yAxRange)-0.36*yAxSize , labels=nams2labs(software.names), at=boxPos[(1:5)*2-1], tick=F, cex.axis=cfg$AxisAnnotationSize, las=1)
}
if(!is.null(file)) dev.off()
par(cfg$parBackup)
return( list(
usr=plotArea,
boxPos=boxPos,
sepPos=sepPos,
labs=names(lrs),
cats=nams2labs(software.names),
mar=mar,
mgp=mgp
))
}
}
softwareBoxPlotsByIntensityRange = function(species="ECOLI", file=NULL)
{
if(!is.null(file))
{
pdf(file=file, onefile=T, width=cfg$PlotWidth*1.5, height=cfg$PlotHeight*3, family="Helvetica", pointsize=9)
}
par( cfg$par )
layout( matrix(c(1,2,3,4), ncol=1, byrow = TRUE), heights=c(1,1,1,.4))
showPartialBoxPlot4Softwares( species=species, fromPart=0, toPart=1/3 )
showPartialBoxPlot4Softwares( species=species, fromPart=1/3, toPart=2/3 )
pa = showPartialBoxPlot4Softwares( species=species, fromPart=2/3, toPart=1 )
par( cfg$par )
par(  mar = c( 1, 5.5, .5, 0.5 ), mgp=c( 0, 0, 0 ) )
emptyPlot(xRange = c(min(pa$boxPos)-0.5, max(pa$boxPos)+0.5), yRange = 0:1, axes = F, grid=F)
axis(1, pos=1, labels=pa$labs, at=pa$boxPos, tick=F, cex.axis=cfg$AxisAnnotationSize, las=2)
axis(1, pos=0, labels=pa$cats, at=pa$boxPos[(1:5)*3-1], tick=F, cex.axis=cfg$AxisAnnotationSize, las=1)
abline(v=pa$sepPos, lty="dotted", lwd=cfg$PlotCurveLineWidth, col="gray" )
if(!is.null(file)) dev.off()
par(cfg$parBackup)
}
softwareBoxPlotsByIntensityRange("ECOLI", outDir + "/software_boxplots_by_range_ecoli.pdf")
softwareBoxPlotsByIntensityRange = function(species="ECOLI", file=NULL)
{
if(!is.null(file))
{
pdf(file=file, onefile=T, width=cfg$PlotWidth*1.5, height=cfg$PlotHeight*3, family="Helvetica", pointsize=9)
}
par( cfg$par )
layout( matrix(c(1,2,3,4), ncol=1, byrow = TRUE), heights=c(1,1,1,.4))
showPartialBoxPlot4Softwares( species=species, fromPart=0, toPart=1/3 )
showPartialBoxPlot4Softwares( species=species, fromPart=1/3, toPart=2/3 )
pa = showPartialBoxPlot4Softwares( species=species, fromPart=2/3, toPart=1 )
par( cfg$par )
par(  mar = c( 1, 5.5, .5, 0.5 ), mgp=c( 0, 0, 0 ) )
emptyPlot(xRange = c(min(pa$boxPos)-0.5, max(pa$boxPos)+0.5), yRange = 0:1, axes = F, grid=F)
axis(1, pos=1, labels=pa$labs, at=pa$boxPos, tick=F, cex.axis=cfg$AxisAnnotationSize, las=2)
axis(1, pos=0, labels=pa$cats, at=pa$boxPos[(1:5)*3-1], tick=F, cex.axis=cfg$AxisAnnotationSize, las=1)
abline(v=pa$sepPos, lty="dotted", lwd=cfg$PlotCurveLineWidth, col="gray" )
if(!is.null(file)) dev.off()
par(cfg$parBackup)
}
softwareBoxPlotsByIntensityRange = function(species="ECOLI", file=NULL)
{
if(!is.null(file))
{
pdf(file=file, onefile=T, width=cfg$PlotWidth*1.5, height=cfg$PlotHeight*3, family="Helvetica", pointsize=9)
}
par( cfg$par )
layout( matrix(c(1,2,3,4), ncol=1, byrow = TRUE), heights=c(1,1,1,.4))
showPartialBoxPlot4Softwares( species=species, fromPart=0, toPart=1/3 )
showPartialBoxPlot4Softwares( species=species, fromPart=1/3, toPart=2/3 )
pa = showPartialBoxPlot4Softwares( species=species, fromPart=2/3, toPart=1 )
par( cfg$par )
par(  mar = c( 1, 5.5, .5, 0.5 ), mgp=c( 0, 0, 0 ) )
emptyPlot(xRange = c(min(pa$boxPos)-0.5, max(pa$boxPos)+0.5), yRange = 0:1, axes = F, grid=F)
axis(1, pos=1, labels=pa$labs, at=pa$boxPos, tick=F, cex.axis=cfg$AxisAnnotationSize, las=2)
axis(1, pos=0, labels=pa$cats, at=pa$boxPos[(1:5)*2-1], tick=F, cex.axis=cfg$AxisAnnotationSize, las=1)
abline(v=pa$sepPos, lty="dotted", lwd=cfg$PlotCurveLineWidth, col="gray" )
if(!is.null(file)) dev.off()
par(cfg$parBackup)
}
softwareBoxPlotsByIntensityRange("ECOLI", outDir + "/software_boxplots_by_range_ecoli.pdf")
softwareBoxPlotsByIntensityRange("YEAST", outDir + "/software_boxplots_by_range_yeast.pdf")
source('~/Dropbox/PAPER_SWATHbenchmark/joerg/fig23/figures/script/makePlots_protOverlap_nobuiltin.r', echo=TRUE)
source('~/Dropbox/PAPER_SWATHbenchmark/joerg/fig23/figures/script/makePlots_protOverlap_nobuiltin.r', echo=TRUE)
source('~/Dropbox/PAPER_SWATHbenchmark/joerg/fig23/figures/script/makePlots_protOverlap_nobuiltin.r', echo=TRUE)
source('~/Dropbox/PAPER_SWATHbenchmark/joerg/fig23/figures/script/makePlots_protOverlap_nobuiltin.r', echo=TRUE)
source('~/Dropbox/PAPER_SWATHbenchmark/joerg/fig23/figures/script/makePlots_protOverlap_nobuiltin.r', echo=TRUE)
lib32 <- read.table(file = "ecolihumanyeast_concat_mayu_IRR_cons_peakview_32sw_curated.txt", sep="\t", header=T, stringsAsFactors = F)
setwd("~/Dropbox/PAPER_SWATHbenchmark/ionlibraries/corrected_libraries/peakview_shifted_iRTs")
loadLibrary <- function(x)
{
if(!require(x, character.only=T, quietly = T, warn.conflicts=F))
{
install.packages(x); library(x, character.only=T, warn.conflicts=F)
}
}
loadLibrary("VennDiagram")
loadLibrary("tidyr")
loadLibrary("dplyr")
loadLibrary("ggplot2")
loadLibrary("readxl")
loadLibrary("classInt")
loadLibrary("scales")
loadLibrary("pander")
loadLibrary("GGally")
lib32 <- read.table(file = "ecolihumanyeast_concat_mayu_IRR_cons_peakview_32sw_curated.txt", sep="\t", header=T, stringsAsFactors = F)
View(lib32)
lib64 <- read.table(file = "ecolihumanyeast_concat_mayu_IRR_cons_peakview_64var_curated.txt", sep="\t", header=T, stringsAsFactors = F)
View(lib32)
precursors32 <- lib32 %>%
group_by(modification_sequence, prec_z) %>%
summarise(n())
View(precursors32)
precursors32 <- lib32 %>%
group_by(modification_sequence, prec_z) %>%
summarise(avg_iRT = mean(RT_detected))
View(precursors32)
neg32 <- nrow(filter(precursors32, avg_iRT < 0))
neg32/nrow(precursors32)
ionlibs <- vector(mode = "list", length = 2)
ionlibs <- c(
read.table(file = "ecolihumanyeast_concat_mayu_IRR_cons_peakview_32sw_curated.txt", sep="\t", header=T, stringsAsFactors = F),
read.table(file = "ecolihumanyeast_concat_mayu_IRR_cons_peakview_64var_curated.txt", sep="\t", header=T, stringsAsFactors = F)
)
names(ionlibs) <- c("32w", "64w")
countPrecursorsNegative_iRT <- function(df){
precursors <- df %>%
group_by(modification_sequence, prec_z) %>%
summarise(avg_iRT = mean(RT_detected))
neg <- nrow(filter(precursors, avg_iRT < 0))
neg_relative <- neg / nrow(precursors)
return(c(neg, neg_relative))
}
sapply(ionlibs, countPrecursorsNegative_iRT)
apply(ionlibs, countPrecursorsNegative_iRT)
lapply(ionlibs, countPrecursorsNegative_iRT)
ionlibs
countPrecursorsNegative_iRT <- function(df){
precursors <- as.data.frame(df) %>%
group_by(modification_sequence, prec_z) %>%
summarise(avg_iRT = mean(RT_detected))
neg <- nrow(filter(precursors, avg_iRT < 0))
neg_relative <- neg / nrow(precursors)
return(c(neg, neg_relative))
}
lapply(ionlibs, countPrecursorsNegative_iRT)
stats_32 <- countPrecursorsNegative_iRT(ionlibs$32w)
countPrecursorsNegative_iRT <- function(df){
precursors <- df %>%
group_by(modification_sequence, prec_z) %>%
summarise(avg_iRT = mean(RT_detected))
neg <- nrow(filter(precursors, avg_iRT < 0))
neg_relative <- neg / nrow(precursors)
return(c(neg, neg_relative))
}
stats_32 <- countPrecursorsNegative_iRT(ionlibs$32w)
ionlib32 <- read.table(file = "ecolihumanyeast_concat_mayu_IRR_cons_peakview_32sw_curated.txt", sep="\t", header=T, stringsAsFactors = F)
ionlib64 <- read.table(file = "ecolihumanyeast_concat_mayu_IRR_cons_peakview_64var_curated.txt", sep="\t", header=T, stringsAsFactors = F)
countPrecursorsNegative_iRT <- function(df){
precursors <- df %>%
group_by(modification_sequence, prec_z) %>%
summarise(avg_iRT = mean(RT_detected))
neg <- nrow(filter(precursors, avg_iRT < 0))
neg_relative <- neg / nrow(precursors)
return(c(neg, neg_relative))
}
stats_32 <- countPrecursorsNegative_iRT(ionlib32)
stats_64 <- countPrecursorsNegative_iRT(ionlib64)
stats_libs <- rbind(
countPrecursorsNegative_iRT(ionlib32),
countPrecursorsNegative_iRT(ionlib64)
)
stats_libs
stats_libs <- rbind(
countPrecursorsNegative_iRT(ionlib32),
countPrecursorsNegative_iRT(ionlib64)
)
row.names(stats_libs) <- c("lib32", "lib64")
col.names(stats_libs) <- c("count_negative_iRT", "relative")
stats_libs2 <- as.data.frame(stats_libs)
names(stats_libs) <- c("count_negative_iRT", "relative")
stats_libs2 <- as.data.frame(stats_libs)
View(stats_libs2)
View(stats_libs)
stats_libs <- as.data.frame(stats_libs)
row.names(stats_libs) <- c("lib32", "lib64")
names(stats_libs) <- c("count_negative_iRT", "relative")
View(stats_libs)
loadLibrary("knitr")
knitr::kable(x = stats_libs, format = "html")
shift32 <- min(ionlib32$RT_detected)
shift64 <- min(ionlib64$RT_detected)
shift <- min(c(shift32, shift64))
loadLibrary("tools")
filename32 <- "ecolihumanyeast_concat_mayu_IRR_cons_peakview_32sw_curated.txt"
filename64 <- "ecolihumanyeast_concat_mayu_IRR_cons_peakview_64var_curated.txt"
write.table(x = ionlib32, file = filename.new.32, sep = "\t", col.names = T, row.names=F)
source('~/.active-rstudio-document', echo=TRUE)
